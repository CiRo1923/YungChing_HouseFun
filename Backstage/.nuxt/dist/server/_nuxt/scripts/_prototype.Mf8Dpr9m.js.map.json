{"file":"_prototype.Mf8Dpr9m.js","mappings":"AAyDO,MAAM,YAAY,CAAC,KAAK,aAAa;AAC1C,MAAI,SAAS;AAEb,MAAI,OAAO,QAAQ,OAAO,QAAQ,SAAU,QAAO;AACnD,MAAI,IAAI,gBAAgB,UAAU,IAAI,gBAAgB,MAAO,QAAO;AACpE,MACE,IAAI,gBAAgB,QACpB,IAAI,gBAAgB,UACpB,IAAI,gBAAgB,YACpB,IAAI,gBAAgB,UACpB,IAAI,gBAAgB,UACpB,IAAI,gBAAgB;AAEpB,WAAO,IAAI,IAAI,YAAY,GAAG;AAEhC,WAAS,UAAU,IAAI,IAAI,YAAA;AAE3B,aAAW,QAAQ,KAAK;AACtB,WAAO,IAAI,IAAI,OAAO,OAAO,IAAI,MAAM,cAAc,UAAU,IAAI,IAAI,CAAC,IAAI,OAAO,IAAI;AAAA,EACzF;AAEA,MAAI,UAAU;AACZ,aAAS,MAAM;AAAA,EACjB;AAEA,SAAO;AACT;AAGO,MAAM,YAAY,CAAC,WAAW,YAAY;AAC/C,MAAI,CAAC,QAAQ,OAAQ,QAAO;AAC5B,QAAM,SAAS,QAAQ,MAAA;AACvB,QAAM,WAAW,CAAC,SAAS;AACzB,WAAO,QAAQ,OAAO,SAAS,YAAY,CAAC,MAAM,QAAQ,IAAI;AAAA,EAChE;AACA,QAAM,YAAY,CAAC,SAAS;AAC1B,WAAO,EAAE,MAAM,QAAQ,IAAI,KAAK,KAAK,KAAK,CAACA,UAAS,OAAOA,UAAS,QAAQ;AAAA,EAC9E;AAEA,MAAI,SAAS,MAAM,KAAK,SAAS,MAAM,GAAG;AACxC,eAAW,OAAO,QAAQ;AACxB,UAAI,SAAS,OAAO,GAAG,CAAC,GAAG;AAMzB,YAAI,CAAC,OAAO,GAAG,EAAG,QAAO,OAAO,QAAQ,EAAE,CAAC,GAAG,GAAG,CAAA,GAAI;AAGrD,kBAAU,OAAO,GAAG,GAAG,OAAO,GAAG,CAAC;AAAA,MACpC,OAAO;AACL,YAAI,UAAU,OAAO,GAAG,CAAC,GAAG;AAC1B,iBAAO,OAAO,QAAQ,EAAE,CAAC,GAAG,GAAG,OAAO,GAAG,GAAG;AAAA,QAC9C,OAAO;AACL,cAAI,CAAC,OAAO,GAAG,EAAG,QAAO,OAAO,QAAQ,EAAE,CAAC,GAAG,GAAG,CAAA,GAAI;AACrD,iBAAO,OAAO,QAAQ;AAAA,YACpB,CAAC,GAAG,GAAG,OAAO,GAAG,EAAE,IAAI,CAAC,MAAM,UAAU,UAAU,OAAO,GAAG,EAAE,KAAK,KAAK,MAAM,IAAI,CAAC;AAAA,UAAA,CACpF;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,UAAU,QAAQ,GAAG,OAAO;AACrC;AAGO,MAAM,YAAY,CAAC,QAAQ;AAChC,SAAO,UAAU,KAAK,CAAC,SAAS;AAC9B,eAAW,OAAO,KAAK;AACrB,UAAI,KAAK,GAAG,GAAG;AACb,YAAI,OAAO,KAAK,GAAG,MAAM,UAAU;AACjC,eAAK,GAAG,IAAI;AAAA,QACd,WAAW,OAAO,KAAK,GAAG,MAAM,UAAU;AACxC,eAAK,GAAG,IAAI;AAAA,QACd,OAAO;AACL,cAAI,MAAM,QAAQ,KAAK,GAAG,CAAC,GAAG;AAC5B,iBAAK,GAAG,IAAI,CAAA;AAAA,UACd,WAAW,OAAO,KAAK,GAAG,MAAM,WAAW;AACzC,iBAAK,GAAG,IAAI,CAAA;AAAA,UACd;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAGO,MAAM,UAAU,CAAC,QAAQ,UAAU;AACxC,QAAM,SAAS,UAAU,KAAK,KAAK,MAAM,KAAK,SAAS,IAAI,MAAM,GAAG,EAAE,CAAC,EAAE,SAAS;AAClF,QAAM,MAAM,UAAU,SAAY,QAAQ;AAC1C,MAAI,SAAS,EAAE,KAAK,MAAM,SAAS,KAAK,GAAG,EAAE,IAAI,KAAK,GAAG,OAAO;AAChE,QAAM,cAAc,KAAK,KAAK,MAAM,IAAI,OAAO,SAAA,EAAW,MAAM,GAAG,EAAE,CAAC,IAAI,CAAA;AAE1E,MAAI,OAAO,YAAY,SAAS,KAAK;AACnC,aAAS,IAAI,GAAG,IAAI,MAAM,YAAY,QAAQ,KAAK,GAAG;AACpD,UAAI,KAAK,KAAK,MAAM,GAAG;AACrB,iBAAS,GAAG,MAAM;AAAA,MACpB,OAAO;AACL,YAAI,MAAM,GAAG;AACX,mBAAS,GAAG,MAAM;AAAA,QACpB,OAAO;AACL,mBAAS,GAAG,MAAM;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAKA,SAAO,UAAU,WAAW,IAAI,SAAS;AAC3C;AAGO,MAAM,cAAc;AAAA,EACzB,IAAI,QAAQ,cAAc;AACxB,UAAM,SAAS,iBAAiB,SAAY,eAAe;AAC3D,UAAM,SAAS,SAAU,OAAO,WAAW,WAAW,SAAS,KAAK,SAAU,SAAS,MAAM;AAC7F,UAAM,QAAQ;AAEd,WAAO,SAAS,OAAO,QAAQ,OAAO,GAAG,IAAI;AAAA,EAC/C;AAAA,EACA,OAAO,QAAQ,cAAc;AAC3B,UAAM,SAAS,iBAAiB,SAAY,eAAe;AAC3D,UAAM,SAAS,SAAU,OAAO,WAAW,WAAW,SAAS,KAAK,SAAU,SAAS,MAAM;AAE7F,WAAO,SAAS,OAAO,QAAQ,MAAM,EAAE,IAAI;AAAA,EAC7C;AACF;AAgXO,MAAM,eAAe,CAAC,SAAS;AACpC,QAAM;AAAA;AAAA,IAEJ;AAAA;AAEF,SAAO,OAAO,KAAK,MAAM,YAAY,EAAE,SAAS;AAClD;AA8nBO,MAAM,kBAAkB,OAAO,SAAS;AAC7C,MAAI;AACF,UAAM,QAAQ,IAAI,IAAI;AAAA,EACxB,SAAS,OAAO;AAAA,EAEhB;AACF;","names":["item"],"sources":["../../../../../scripts/_prototype.js"],"sourcesContent":["// 遞迴\r\nexport const recursive = (obj, key, exec, finish) => {\r\n  let recursiveIndex = 0\r\n  const arrayWithoutHoles = (arr) => {\r\n    const toArray = () => {\r\n      const len = arr.length\r\n      const arr2 = new Array(len)\r\n\r\n      for (let i = 0; i < len; i += 1) {\r\n        arr2[i] = arr[i]\r\n      }\r\n\r\n      return arr2\r\n    }\r\n\r\n    if (Array.isArray(arr)) {\r\n      return toArray()\r\n    }\r\n  }\r\n  const foeEach = (object, parentPath) => {\r\n    recursiveIndex++\r\n\r\n    // console.log(object.constructor)\r\n\r\n    if (object.constructor === Object) {\r\n      const path = parentPath ? [].concat(arrayWithoutHoles(parentPath), [0]) : []\r\n\r\n      exec(object, path)\r\n\r\n      if (object[key]) {\r\n        foeEach(object[key], path)\r\n      }\r\n    } else {\r\n      for (let i = 0; i < object.length; i += 1) {\r\n        const item = object[i]\r\n        const index = i\r\n        const path = parentPath ? [].concat(arrayWithoutHoles(parentPath), [index]) : []\r\n\r\n        exec(item, path)\r\n\r\n        if (item[key]) {\r\n          foeEach(item[key], path)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (--recursiveIndex === 0 && finish) {\r\n      finish(object)\r\n    }\r\n\r\n    return object\r\n  }\r\n\r\n  foeEach(obj, [])\r\n}\r\n\r\n// 深度複製\r\nexport const deepClone = (obj, callback) => {\r\n  let object = null\r\n\r\n  if (obj == null || typeof obj !== 'object') return obj\r\n  if (obj.constructor !== Object && obj.constructor !== Array) return obj\r\n  if (\r\n    obj.constructor === Date ||\r\n    obj.constructor === RegExp ||\r\n    obj.constructor === Function ||\r\n    obj.constructor === String ||\r\n    obj.constructor === Number ||\r\n    obj.constructor === Boolean\r\n  )\r\n    return new obj.constructor(obj)\r\n\r\n  object = object || new obj.constructor()\r\n\r\n  for (const name in obj) {\r\n    object[name] = typeof object[name] === 'undefined' ? deepClone(obj[name]) : object[name]\r\n  }\r\n\r\n  if (callback) {\r\n    callback(object)\r\n  }\r\n\r\n  return object\r\n}\r\n\r\n// 深度合併\r\nexport const deepMerge = (target, ...sources) => {\r\n  if (!sources.length) return target\r\n  const source = sources.shift()\r\n  const isObject = (item) => {\r\n    return item && typeof item === 'object' && !Array.isArray(item)\r\n  }\r\n  const isShallow = (item) => {\r\n    return !(Array.isArray(item) && item.find((item) => typeof item === 'object'))\r\n  }\r\n\r\n  if (isObject(target) && isObject(source)) {\r\n    for (const key in source) {\r\n      if (isObject(source[key])) {\r\n        // console.log(key)\r\n        // console.log(source[key])\r\n        // console.log(target[key])\r\n        // console.log('------------------')\r\n\r\n        if (!target[key]) Object.assign(target, { [key]: {} })\r\n        // Object.assign(target, { [key]: source[key].map((item, index) => deepMerge(target[key][index] || item, item)) });\r\n\r\n        deepMerge(target[key], source[key])\r\n      } else {\r\n        if (isShallow(source[key])) {\r\n          Object.assign(target, { [key]: source[key] })\r\n        } else {\r\n          if (!target[key]) Object.assign(target, { [key]: [] })\r\n          Object.assign(target, {\r\n            [key]: source[key].map((item, index) => deepMerge(target[key][index] || item, item)),\r\n          })\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return deepMerge(target, ...sources)\r\n}\r\n\r\n// 清空物件資料\r\nexport const emptyData = (obj) => {\r\n  return deepClone(obj, (data) => {\r\n    for (const key in obj) {\r\n      if (data[key]) {\r\n        if (typeof data[key] === 'string') {\r\n          data[key] = ''\r\n        } else if (typeof data[key] === 'number') {\r\n          data[key] = null\r\n        } else {\r\n          if (Array.isArray(data[key])) {\r\n            data[key] = []\r\n          } else if (typeof data[key] !== 'boolean') {\r\n            data[key] = {}\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\n// 小數點設定\r\nexport const toFixed = (number, fixed) => {\r\n  const length = number && /\\./.test(number) ? (number + '').split('.')[1].length : 0\r\n  const fix = fixed !== undefined ? fixed : length\r\n  let result = +(Math.round(number + `e+${fix}`) + `e-${fix}`) || 0\r\n  const pointNumber = /\\./.test(result) ? result.toString().split('.')[1] : []\r\n\r\n  if (fix && pointNumber.length < fix) {\r\n    for (let i = 0; i < fix - pointNumber.length; i += 1) {\r\n      if (/\\./.test(result)) {\r\n        result = `${result}0`\r\n      } else {\r\n        if (i === 0) {\r\n          result = `${result}.0`\r\n        } else {\r\n          result = `${result}0`\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // console.log(/\\./.test(result))\r\n  // console.log(pointNumber)\r\n\r\n  return number || number === 0 ? result : null\r\n}\r\n\r\n// 千分位設定\r\nexport const numberComma = {\r\n  add(number, isReturnZero) {\r\n    const isZero = isReturnZero !== undefined ? isReturnZero : true\r\n    const amount = number ? (typeof number === 'number' ? number + '' : number) : isZero ? '0' : ''\r\n    const regex = /\\B(?=(\\d{3})+(?!\\d))/g\r\n\r\n    return amount ? amount.replace(regex, ',') : ''\r\n  },\r\n  remove(number, isReturnZero) {\r\n    const isZero = isReturnZero !== undefined ? isReturnZero : true\r\n    const amount = number ? (typeof number === 'number' ? number + '' : number) : isZero ? '0' : ''\r\n\r\n    return amount ? amount.replace(/,/g, '') : ''\r\n  },\r\n}\r\n\r\n// 補 0\r\nexport const onAddZero = (number) => {\r\n  const value = typeof number === 'string' ? Number(number) : number\r\n\r\n  return value > 9 ? value : `0${value}`\r\n}\r\n\r\n// 格式化日期\r\nexport const onFormatDate = (date, format) => {\r\n  // ---- helpers ----\r\n  const pad2 = (n) => String(n).padStart(2, '0')\r\n\r\n  const getSeparator = (fmt) => {\r\n    const m = fmt.match(/\\W/)\r\n    return m ? m[0] : ''\r\n  }\r\n\r\n  const parseTimeFromDateString = (input) => {\r\n    // 原本邏輯是「format 需要 hh/mm/ss 且 date 字串含有時間」才抓，不然補 00\r\n    // 這邊一樣：只抓 \"HH:MM:SS\" 形式\r\n    const m = typeof input === 'string' ? input.match(/(\\d{2}):(\\d{2}):(\\d{2})/) : null\r\n    if (!m) return null\r\n    return { hh: m[1], mm: m[2], ss: m[3] }\r\n  }\r\n\r\n  const toLocalYMD = (ms) => {\r\n    // 避免 toISOString() 的 UTC 切日，改成本地日期\r\n    const d = new Date(ms)\r\n    const y = d.getFullYear()\r\n    const m = pad2(d.getMonth() + 1)\r\n    const day = pad2(d.getDate())\r\n    return { YYYY: String(y), MM: m, DD: day }\r\n  }\r\n\r\n  const safeMsFromYMD = (y, mo, d, hh, mm, ss) => {\r\n    // 手動組出 Date(year, monthIndex, day, ...) 避開 iOS 對字串解析\r\n    // 若沒有時間，固定用 12:00:00 避免時區切日\r\n    const hasTime = hh != null && mm != null && ss != null\r\n    const H = hasTime ? hh : 12\r\n    const M = hasTime ? mm : 0\r\n    const S = hasTime ? ss : 0\r\n    const dt = new Date(y, mo - 1, d, H, M, S, 0)\r\n    const ms = dt.getTime()\r\n    return Number.isNaN(ms) ? null : ms\r\n  }\r\n\r\n  const parseIsoWithTzToMs = (s) => {\r\n    // 新增：處理 ISO 8601 含「小數秒 + 時區」的字串\r\n    // 例：2026-02-03T17:50:08.5662303+08:00\r\n    // 同時支援：\r\n    // 1) Z 結尾（UTC）\r\n    // 2) 沒有小數秒（2026-02-03T17:50:08+08:00）\r\n    // 3) 沒有冒號的 offset（+0800）\r\n    // 說明：避免依賴 new Date(string) 的解析（iOS 對此類格式常不穩定），改為手動計算 UTC ms\r\n    const m = String(s)\r\n      .trim()\r\n      .match(\r\n        /^(\\d{4})-(\\d{2})-(\\d{2})[T\\s](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(?:Z|([+-])(\\d{2}):?(\\d{2}))$/\r\n      )\r\n    if (!m) return null\r\n\r\n    const y = +m[1]\r\n    const mo = +m[2]\r\n    const d = +m[3]\r\n    const hh = +m[4]\r\n    const mm = +m[5]\r\n    const ss = +m[6]\r\n\r\n    // 小數秒可能很多位（例如 5662303），JS 只能到毫秒\r\n    // 取前三位並右補 0，轉為毫秒\r\n    const frac = (m[7] || '').slice(0, 3).padEnd(3, '0')\r\n    const msPart = frac ? +frac : 0\r\n\r\n    // 先以 Date.UTC 組出「假設為 UTC」的時間\r\n    let utcMs = Date.UTC(y, mo - 1, d, hh, mm, ss, msPart)\r\n\r\n    // 若帶有 offset（+08:00 / -05:30 等），需換算成真正的 UTC ms\r\n    // +08:00 表示當地時間比 UTC 快 8 小時，所以要扣回去\r\n    if (m[8]) {\r\n      const sign = m[8] === '+' ? 1 : -1\r\n      const offH = +m[9]\r\n      const offM = +m[10]\r\n      const offsetMin = sign * (offH * 60 + offM)\r\n      utcMs -= offsetMin * 60 * 1000\r\n    }\r\n\r\n    return Number.isNaN(utcMs) ? null : utcMs\r\n  }\r\n\r\n  const parseToMs = (input) => {\r\n    if (!input && input !== 0) return null\r\n\r\n    // Date 物件\r\n    if (input instanceof Date) {\r\n      const ms = input.getTime()\r\n      return Number.isNaN(ms) ? null : ms\r\n    }\r\n\r\n    // number (timestamp)\r\n    if (typeof input === 'number') {\r\n      const d = new Date(input)\r\n      return Number.isNaN(d.getTime()) ? null : input\r\n    }\r\n\r\n    // .NET: /Date(1690000000000+0800)/\r\n    if (typeof input === 'string' && /^\\/Date/.test(input)) {\r\n      const m = input.match(/\\((\\d+)(?:[-+]\\d+)?\\)/)\r\n      return m ? Number(m[1]) : null\r\n    }\r\n\r\n    const s = String(input).trim()\r\n    if (!s) return null\r\n\r\n    // YYYYMMDD\r\n    if (/^\\d{8}$/.test(s)) {\r\n      const y = parseInt(s.slice(0, 4), 10)\r\n      const mo = parseInt(s.slice(4, 6), 10)\r\n      const d = parseInt(s.slice(6, 8), 10)\r\n      return safeMsFromYMD(y, mo, d)\r\n    }\r\n\r\n    // YYYY-MM-DD / YYYY/MM/DD\r\n    {\r\n      const m = s.match(/^(\\d{4})[-/](\\d{1,2})[-/](\\d{1,2})$/)\r\n      if (m) {\r\n        const y = parseInt(m[1], 10)\r\n        const mo = parseInt(m[2], 10)\r\n        const d = parseInt(m[3], 10)\r\n        return safeMsFromYMD(y, mo, d)\r\n      }\r\n    }\r\n\r\n    // YYYY-MM-DD HH:mm:ss / YYYY/MM/DD HH:mm:ss / YYYY-MM-DDTHH:mm:ss\r\n    {\r\n      const m = s.match(/^(\\d{4})[-/](\\d{1,2})[-/](\\d{1,2})(?:T|\\s)(\\d{1,2}):(\\d{1,2}):(\\d{1,2})$/)\r\n      if (m) {\r\n        const y = parseInt(m[1], 10)\r\n        const mo = parseInt(m[2], 10)\r\n        const d = parseInt(m[3], 10)\r\n        const hh = parseInt(m[4], 10)\r\n        const mm = parseInt(m[5], 10)\r\n        const ss = parseInt(m[6], 10)\r\n        return safeMsFromYMD(y, mo, d, hh, mm, ss)\r\n      }\r\n    }\r\n\r\n    // 新增：ISO 8601 with fractional seconds + timezone\r\n    // 例如：2026-02-03T17:50:08.5662303+08:00\r\n    {\r\n      const isoMs = parseIsoWithTzToMs(s)\r\n      if (isoMs != null) return isoMs\r\n    }\r\n\r\n    // string / others\r\n    // 這裡仍然可能因格式太自由而不穩，所以先把 '-' 轉成 '/'\r\n    // 舊 iOS 對 '/' 相對友善一點\r\n    const ms = +new Date(s.replace(/-/g, '/'))\r\n    return Number.isNaN(ms) ? null : ms\r\n  }\r\n\r\n  // ---- main ----\r\n  const ms = parseToMs(date)\r\n  if (ms == null) return ''\r\n\r\n  // format 沒帶值：回傳 +new Date(計算好的日期) 的結果（timestamp number）\r\n  // (+new Date(ms) === ms，但寫清楚符合需求)\r\n  if (!format || !String(format).trim()) {\r\n    return +new Date(ms)\r\n  }\r\n\r\n  const fmt = String(format).trim()\r\n  const sep = getSeparator(fmt)\r\n\r\n  // 用本地取日期（避免 UTC 切日）\r\n  const ymd = toLocalYMD(ms)\r\n  const YYYY = /YYYY/.test(fmt) ? ymd.YYYY : ''\r\n  const MM = /MM/.test(fmt) ? ymd.MM : ''\r\n  const DD = /DD/.test(fmt) ? ymd.DD : ''\r\n\r\n  // 組日期字串\r\n  let dateStr = ''\r\n  if (YYYY) dateStr = YYYY\r\n  if (MM) dateStr = dateStr ? `${dateStr}${sep}${MM}` : MM\r\n  if (DD) dateStr = dateStr ? `${dateStr}${sep}${DD}` : DD\r\n\r\n  // 組時間字串（只在 format 有 hh/mm/ss 才開始帶時間）\r\n  let timeStr = ''\r\n  const needsHh = /hh/.test(fmt)\r\n  const needsMm = /mm/.test(fmt)\r\n  const needsSs = /ss/.test(fmt)\r\n\r\n  if (needsHh || needsMm || needsSs) {\r\n    const t = parseTimeFromDateString(date) || { hh: '00', mm: '00', ss: '00' }\r\n\r\n    // 最穩方式：直接用原 fmt 的時間部分（從第一個 h/m/s token 開始）\r\n    const idx = fmt.search(/hh|mm|ss/)\r\n    if (idx !== -1) {\r\n      const timeFmt = fmt.slice(idx)\r\n      let tStr = timeFmt\r\n      if (needsHh) tStr = tStr.replace('hh', t.hh)\r\n      if (needsMm) tStr = tStr.replace('mm', t.mm)\r\n      if (needsSs) tStr = tStr.replace('ss', t.ss)\r\n      timeStr = ` ${tStr}`\r\n    }\r\n  }\r\n\r\n  return `${dateStr}${timeStr}`\r\n}\r\n\r\n// 計算日期\r\nexport const onValueToDateRange = (today, date, format) => {\r\n  // ---- helpers (all inside) ----\r\n  const pad2 = (n) => String(n).padStart(2, '0')\r\n\r\n  // 輸出 YYYY-MM-DD\r\n  const formatYMD = (y, m, d) => `${y}-${pad2(m)}-${pad2(d)}`\r\n\r\n  // 以 UTC 方式建立一個「日曆日期」(用 UTC noon 避免任何跨日)\r\n  const makeUtcDate = (y, m, d) => new Date(Date.UTC(y, m - 1, d, 12, 0, 0, 0))\r\n\r\n  const getYMDFromUtcDate = (dt) => {\r\n    return {\r\n      y: dt.getUTCFullYear(),\r\n      m: dt.getUTCMonth() + 1,\r\n      d: dt.getUTCDate(),\r\n    }\r\n  }\r\n\r\n  // 支援 number / Date / 'YYYY-MM-DD' / 'YYYY/MM/DD' / 'YYYYMMDD' / .NET /Date(...)/\r\n  // 注意：絕對不使用 new Date('YYYY-MM-DD')，避免舊 iOS/Safari 解析坑\r\n  const parseToUtcDate = (v) => {\r\n    if (v instanceof Date) {\r\n      // 取這個瞬間在 UTC 的年月日，轉成「日曆日期」(UTC noon)\r\n      const y = v.getUTCFullYear()\r\n      const m = v.getUTCMonth() + 1\r\n      const d = v.getUTCDate()\r\n      return makeUtcDate(y, m, d)\r\n    }\r\n\r\n    if (typeof v === 'number') {\r\n      const d0 = new Date(v)\r\n      if (isNaN(d0.getTime())) return null\r\n      const y = d0.getUTCFullYear()\r\n      const m = d0.getUTCMonth() + 1\r\n      const d = d0.getUTCDate()\r\n      return makeUtcDate(y, m, d)\r\n    }\r\n\r\n    const s = String(v || '').trim()\r\n    if (!s) return null\r\n\r\n    // .NET: /Date(1690000000000+0800)/\r\n    if (/^\\/Date/.test(s)) {\r\n      const m = s.match(/\\((\\d+)(?:[-+]\\d+)?\\)/)\r\n      if (!m) return null\r\n      const d0 = new Date(Number(m[1]))\r\n      if (isNaN(d0.getTime())) return null\r\n      const y = d0.getUTCFullYear()\r\n      const mo = d0.getUTCMonth() + 1\r\n      const d = d0.getUTCDate()\r\n      return makeUtcDate(y, mo, d)\r\n    }\r\n\r\n    // YYYYMMDD\r\n    if (/^\\d{8}$/.test(s)) {\r\n      const y = parseInt(s.slice(0, 4), 10)\r\n      const mo = parseInt(s.slice(4, 6), 10)\r\n      const d = parseInt(s.slice(6, 8), 10)\r\n      const dt = makeUtcDate(y, mo, d)\r\n      return isNaN(dt.getTime()) ? null : dt\r\n    }\r\n\r\n    // YYYY-MM-DD or YYYY/MM/DD\r\n    {\r\n      const m = s.match(/^(\\d{4})[-/](\\d{1,2})[-/](\\d{1,2})$/)\r\n      if (m) {\r\n        const y = parseInt(m[1], 10)\r\n        const mo = parseInt(m[2], 10)\r\n        const d = parseInt(m[3], 10)\r\n        const dt = makeUtcDate(y, mo, d)\r\n        return isNaN(dt.getTime()) ? null : dt\r\n      }\r\n    }\r\n\r\n    // 其他格式：先把 '-' 轉成 '/' 再 new Date，盡量避開舊 iOS 坑\r\n    // 但這條路本來就不保證所有格式都穩，能不用就不用\r\n    const fallback = new Date(s.replace(/-/g, '/'))\r\n    if (isNaN(fallback.getTime())) return null\r\n    const y = fallback.getUTCFullYear()\r\n    const mo = fallback.getUTCMonth() + 1\r\n    const d = fallback.getUTCDate()\r\n    return makeUtcDate(y, mo, d)\r\n  }\r\n\r\n  const daysInMonth = (y, m) => new Date(Date.UTC(y, m, 0)).getUTCDate()\r\n\r\n  const addDays = (dt, n) => {\r\n    const d = new Date(dt.getTime())\r\n    d.setUTCDate(d.getUTCDate() + n)\r\n    return d\r\n  }\r\n\r\n  const addMonthsSafe = (dt, months) => {\r\n    const y = dt.getUTCFullYear()\r\n    const m0 = dt.getUTCMonth() + 1\r\n    const d0 = dt.getUTCDate()\r\n\r\n    const targetIndex = m0 - 1 + months\r\n    const targetY = y + Math.floor(targetIndex / 12)\r\n    const targetM = (((targetIndex % 12) + 12) % 12) + 1\r\n\r\n    const maxD = daysInMonth(targetY, targetM)\r\n    const nextD = Math.min(d0, maxD)\r\n\r\n    return makeUtcDate(targetY, targetM, nextD)\r\n  }\r\n\r\n  const addYearsSafe = (dt, years) => addMonthsSafe(dt, years * 12)\r\n\r\n  // ---- main ----\r\n  const base = parseToUtcDate(today)\r\n  if (!base) return null\r\n\r\n  const baseYMD = getYMDFromUtcDate(base)\r\n  const todayStr = formatYMD(baseYMD.y, baseYMD.m, baseYMD.d)\r\n\r\n  const input = String(date || '')\r\n    .trim()\r\n    .toLowerCase()\r\n\r\n  // now year => [今年1/1, 今年今天]\r\n  if (input === 'now year') {\r\n    const start = makeUtcDate(baseYMD.y, 1, 1)\r\n    const s = getYMDFromUtcDate(start)\r\n    return [onFormatDate(formatYMD(s.y, s.m, s.d), format), onFormatDate(todayStr, format)]\r\n  }\r\n\r\n  // last year => [去年1/1, 去年12/31]\r\n  if (input === 'last year') {\r\n    const y = baseYMD.y - 1\r\n    return [onFormatDate(formatYMD(y, 1, 1), format), onFormatDate(formatYMD(y, 12, 31), format)]\r\n  }\r\n\r\n  // +N/-N + unit (allow \"3 month\", \"-1year\", \"10 day\", \"-5 day\")\r\n  const m = input.match(/^([+-]?\\d+)\\s*(year|month|day)s?$/i)\r\n  if (!m) return null\r\n\r\n  const amount = parseInt(m[1], 10)\r\n  const unit = m[2].toLowerCase()\r\n\r\n  let result = base\r\n  if (unit === 'day') result = addDays(base, amount)\r\n  if (unit === 'month') result = addMonthsSafe(base, amount)\r\n  if (unit === 'year') result = addYearsSafe(base, amount)\r\n\r\n  const r = getYMDFromUtcDate(result)\r\n  return [onFormatDate(formatYMD(r.y, r.m, r.d), format), onFormatDate(todayStr, format)]\r\n}\r\n\r\n// 轉換 html tag\r\nexport const replaceSymbolToTag = (content, symbol, tag) => {\r\n  return content.replace(new RegExp(`\\\\${symbol}`, 'g'), tag)\r\n  // return ''\r\n}\r\n\r\n// 判斷特殊字元長度\r\nexport const unicodLength = (text) => {\r\n  const regexUnicode =\r\n    // eslint-disable-next-line no-misleading-character-class\r\n    /\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\u1ab0-\\u1aff\\u1dc0-\\u1dff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\u1ab0-\\u1aff\\u1dc0-\\u1dff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\u1ab0-\\u1aff\\u1dc0-\\u1dff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\u1ab0-\\u1aff\\u1dc0-\\u1dff]|\\ud83c[\\udffb-\\udfff])?)*/g\r\n\r\n  return text ? text.match(regexUnicode).length : 0\r\n}\r\n\r\n// 取得裝置\r\nexport const onDevice = () => {\r\n  const angle = window.screen.orientation ? window.screen.orientation.angle : 0\r\n  const PCMinWidth = 1024\r\n  const mobileWidth = 740\r\n  const userAgent = navigator.userAgent\r\n  const isPCPad = angle === 0 && window.innerWidth > mobileWidth && window.innerWidth < PCMinWidth // 在桌機時 resize 模擬 Pad 的尺寸\r\n  const isAndroidPad = /Android|webOS|BlackBerry/i.test(userAgent)\r\n  const is16BelowPad = /iPad/i.test(userAgent) // ios 16 以下的系統\r\n  const is17AbovePad = angle !== 0 && /Mac OS X/i.test(userAgent) // iso 17 以上的系統\r\n  const isAndroidMobile = /Android|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)\r\n  const isIPhoneMobile =\r\n    (angle !== 0 && window.innerWidth > 730 && window.innerWidth < 815) || /iPhone/i.test(userAgent)\r\n\r\n  if (window.innerWidth <= mobileWidth || isAndroidMobile || isIPhoneMobile) {\r\n    return 'm'\r\n  }\r\n  if (isPCPad || isAndroidPad || is16BelowPad || is17AbovePad) {\r\n    return 't'\r\n  }\r\n\r\n  return 'p'\r\n}\r\n\r\n// 取得裝置\r\nexport const getOS = () => {\r\n  let userAgent = navigator.userAgent.toLocaleLowerCase()\r\n  let osName = null\r\n\r\n  switch (true) {\r\n    case /android/.test(userAgent):\r\n      osName = 'Android'\r\n      break\r\n    case /iphone|ipad/.test(userAgent):\r\n      osName = 'IOS'\r\n      break\r\n    default:\r\n      osName = 'Unknown'\r\n      break\r\n  }\r\n\r\n  return osName\r\n}\r\n\r\n// 取得瀏覽器\r\nexport const getBrowser = () => {\r\n  let userAgent = navigator.userAgent.toLocaleLowerCase()\r\n  let browserName = null\r\n\r\n  switch (true) {\r\n    case /line/.test(userAgent):\r\n      browserName = 'Line'\r\n      break\r\n    case /fbav/.test(userAgent):\r\n      browserName = 'FaceBook'\r\n      break\r\n    case /chrome|chromium|crios/.test(userAgent):\r\n      browserName = 'Chrome'\r\n      break\r\n    case /firefox|fxios/.test(userAgent):\r\n      browserName = 'Firefox'\r\n      break\r\n    case /safari/.test(userAgent):\r\n      browserName = 'Safari'\r\n      break\r\n    case /opr/.test(userAgent):\r\n      browserName = 'Opera'\r\n      break\r\n    case /edg/.test(userAgent):\r\n      browserName = 'Edge'\r\n      break\r\n    default:\r\n      browserName = 'Unknown'\r\n      break\r\n  }\r\n\r\n  return browserName\r\n}\r\n\r\n// 產出 uuid\r\nexport const onUUID = () => {\r\n  if (typeof crypto === 'object') {\r\n    if (typeof crypto.randomUUID === 'function') {\r\n      return crypto.randomUUID()\r\n    }\r\n    if (typeof crypto.getRandomValues === 'function' && typeof Uint8Array === 'function') {\r\n      const callback = (c) => {\r\n        const num = Number(c)\r\n        return (num ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (num / 4)))).toString(\r\n          16\r\n        )\r\n      }\r\n      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, callback)\r\n    }\r\n  }\r\n  let timestamp = new Date().getTime()\r\n  let perforNow =\r\n    (typeof performance !== 'undefined' && performance.now && performance.now() * 1000) || 0\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    let random = Math.random() * 16\r\n    if (timestamp > 0) {\r\n      random = ((timestamp + random) % 16) | 0\r\n      timestamp = Math.floor(timestamp / 16)\r\n    } else {\r\n      random = ((perforNow + random) % 16) | 0\r\n      perforNow = Math.floor(perforNow / 16)\r\n    }\r\n    return (c === 'x' ? random : (random & 0x3) | 0x8).toString(16)\r\n  })\r\n}\r\n\r\n// 轉換時間格式\r\nexport const timeFormat = {\r\n  /**\r\n   * 把各種 input 轉成「毫秒 ms」\r\n   * 支援：\r\n   * - number：預設視為 ms（也可開 auto 判斷秒/毫秒）\r\n   * - '300'：同上（純數字字串）\r\n   * - '1500ms' / '30s' / '5m' / '2h'\r\n   * - 'mm:ss' 例如 '03:15'\r\n   * - 'hh:mm:ss' 例如 '01:02:03'\r\n   */\r\n  parseToMs(input, props) {\r\n    if (input == null || input === '') return null\r\n    const numberUnit = props && props.numberUnit ? props.numberUnit : 'ms'\r\n    const autoNumberUnit = props && props.autoNumberUnit ? props.autoNumberUnit : false\r\n\r\n    // Date\r\n    if (input instanceof Date) {\r\n      const ms = input.getTime()\r\n      return Number.isFinite(ms) ? ms : null\r\n    }\r\n\r\n    // number\r\n    if (typeof input === 'number') {\r\n      if (!Number.isFinite(input)) return null\r\n      if (autoNumberUnit) {\r\n        // 常見：< 1e12 可能是秒；但你需求說 300 也可能是毫秒\r\n        // 所以 autoNumberUnit 建議只在你能接受「猜測」時開\r\n        return input < 1e10 ? input * 1000 : input\r\n      }\r\n      return numberUnit === 's' ? input * 1000 : input\r\n    }\r\n\r\n    // string\r\n    if (typeof input !== 'string') return null\r\n    const raw = input.trim()\r\n    if (!raw) return null\r\n\r\n    // 1) 先判斷是否是 mm:ss / hh:mm:ss\r\n    // mm:ss (兩段)\r\n    if (/^\\d{1,2}:\\d{2}$/.test(raw)) {\r\n      const [mm, ss] = raw.split(':').map(Number)\r\n      return (mm * 60 + ss) * 1000\r\n    }\r\n    // hh:mm:ss (三段)\r\n    if (/^\\d{1,2}:\\d{2}:\\d{2}$/.test(raw)) {\r\n      const [hh, mm, ss] = raw.split(':').map(Number)\r\n      return (hh * 3600 + mm * 60 + ss) * 1000\r\n    }\r\n\r\n    // 2) 單位字串：1500ms / 30s / 5m / 2h\r\n    const unitMatch = raw.match(/^(-?\\d+(?:\\.\\d+)?)\\s*(ms|s|m|h)$/i)\r\n    if (unitMatch) {\r\n      const n = Number(unitMatch[1])\r\n      const unit = unitMatch[2].toLowerCase()\r\n      if (!Number.isFinite(n)) return null\r\n      const factor = unit === 'ms' ? 1 : unit === 's' ? 1000 : unit === 'm' ? 60000 : 3600000\r\n      return n * factor\r\n    }\r\n\r\n    // 3) 純數字字串：'300'\r\n    if (/^-?\\d+(?:\\.\\d+)?$/.test(raw)) {\r\n      const n = Number(raw)\r\n      if (!Number.isFinite(n)) return null\r\n      return numberUnit === 's' ? n * 1000 : n\r\n    }\r\n\r\n    return null\r\n  },\r\n\r\n  /**\r\n   * 把 ms 格式化成字串\r\n   * format:\r\n   * - 'mm:ss'\r\n   * - 'hh:mm:ss'\r\n   *\r\n   * 注意：mm:ss 會顯示「總分鐘」（例如 90 分鐘會顯示 90:00，不會轉成 01:30:00）\r\n   */\r\n  formatMs(ms, format, props) {\r\n    if (ms == null) return ''\r\n    if (!Number.isFinite(ms)) return ''\r\n\r\n    const sign = ms < 0 ? '-' : ''\r\n    const absMs = Math.abs(ms)\r\n    const totalSec = Math.floor(absMs / 1000)\r\n\r\n    const pad2 = (n) => String(n).padStart(2, '0')\r\n    const decimals = props && Number.isFinite(props.decimals) ? props.decimals : 3\r\n\r\n    // 拆成 h/m/s（用於組合輸出）\r\n    const hh = Math.floor(totalSec / 3600)\r\n    // const ss = totalSec % 60\r\n\r\n    // ---- 單位輸出（小數/整數）----\r\n    // EX：300s -> 5m -> 0.083h\r\n    if (format === 'hh' || format === 'h') {\r\n      const hours = absMs / 3600000\r\n      // hh / h 都輸出小數，不補零\r\n      return `${sign}${Number(hours.toFixed(decimals)).toString()}`\r\n    }\r\n    if (format === 'mm' || format === 'm') {\r\n      const minutes = absMs / 60000\r\n      // 兩位分鐘（整數、補零）\r\n      if (format === 'mm') return `${sign}${pad2(Math.floor(minutes))}`\r\n      // m：分鐘小數 or 整數\r\n      return `${sign}${Number(minutes.toFixed(decimals)).toString()}`\r\n    }\r\n    if (format === 'ss' || format === 's') {\r\n      const seconds = absMs / 1000\r\n      if (format === 'ss') return `${sign}${pad2(Math.floor(seconds))}`\r\n      return `${sign}${Math.floor(seconds)}`\r\n    }\r\n\r\n    // ---- 組合輸出（保留符號，replace h+/m+/s+）----\r\n    const fmt = format || 'mm:ss'\r\n    const hasH = /h+/i.test(fmt)\r\n\r\n    // 有 h：m = 分鐘餘數(0-59)；沒 h：m = 總分鐘\r\n    const totalMin = Math.floor(totalSec / 60)\r\n    const minR = Math.floor((totalSec % 3600) / 60)\r\n    const secR = totalSec % 60\r\n\r\n    const pick = (token) => {\r\n      const t = token.toLowerCase()\r\n      const len = token.length\r\n\r\n      if (t[0] === 'h') {\r\n        const v = hh\r\n        return len >= 2 ? pad2(v) : String(v)\r\n      }\r\n\r\n      if (t[0] === 'm') {\r\n        const v = hasH ? minR : totalMin\r\n        return len >= 2 ? pad2(v) : String(v)\r\n      }\r\n\r\n      // s\r\n      const v = secR\r\n      return len >= 2 ? pad2(v) : String(v)\r\n    }\r\n\r\n    return sign + fmt.replace(/(h+|m+|s+)/gi, (token) => pick(token))\r\n  },\r\n\r\n  /**\r\n   * input -> ms -> format\r\n   */\r\n  toTimeString(input, props) {\r\n    const { parseToMs, formatMs } = timeFormat\r\n    const isPropsObject = typeof props === 'object'\r\n    const format = isPropsObject\r\n      ? props && props.format\r\n        ? props.format\r\n        : 'mm:ss'\r\n      : props || 'mm:ss'\r\n    const parseOptions = isPropsObject && props && props.parseOptions ? props.parseOptions : {}\r\n    const ms = parseToMs(input, parseOptions)\r\n    if (ms == null) return ''\r\n    return formatMs(ms, format, {\r\n      format,\r\n      parseOptions,\r\n    })\r\n  },\r\n}\r\n\r\n// 倒數計時\r\nexport const countdown = {\r\n  _format: 'mm:ss',\r\n  _stopFn: null, // 記錄目前倒數的 stop，讓 onStop 可直接停止\r\n  _doneFn: null, // 記錄目前倒數的 onDone，讓 onStop 也能觸發\r\n  /**\r\n   * 嘗試把各種輸入轉成毫秒時間戳 (ms)\r\n   * 支援：\r\n   * - number：視為 ms（也支援秒，會自動判斷）\r\n   * - numeric string：同上\r\n   * - ISO string：2026-02-05T11:32:45.5052229+08:00\r\n   * - YYYY-MM-DD / YYYY/MM/DD / YYYY.MM.DD\r\n   * - YYYY-MM-DD HH:mm:ss / YYYY/MM/DD HH:mm:ss / YYYY.MM.DD HH:mm:ss\r\n   */\r\n  _parseToMs(input) {\r\n    if (input == null || input === '') return null\r\n\r\n    // Date 物件\r\n    if (input instanceof Date) {\r\n      const ms = input.getTime()\r\n      return Number.isFinite(ms) ? ms : null\r\n    }\r\n\r\n    // number\r\n    if (typeof input === 'number') {\r\n      if (!Number.isFinite(input)) return null\r\n      // 小於 1e12 通常是「秒」(例如 1770262224)，大於等於 1e12 通常是「毫秒」\r\n      return input < 1e12 ? Math.round(input * 1000) : Math.round(input)\r\n    }\r\n\r\n    // string\r\n    const s = String(input).trim()\r\n    if (!s) return null\r\n\r\n    // 純數字字串：當作 timestamp（秒或毫秒）\r\n    if (/^\\d+$/.test(s)) {\r\n      const n = Number(s)\r\n      if (!Number.isFinite(n)) return null\r\n      return n < 1e12 ? Math.round(n * 1000) : Math.round(n)\r\n    }\r\n\r\n    // 先試原生 Date.parse（ISO / RFC 等大多吃得到）\r\n    const parsed = Date.parse(s)\r\n    if (Number.isFinite(parsed)) return parsed\r\n\r\n    // 自己處理：YYYY[-/.]MM[-/.]DD (可選時間)\r\n    // 例：2026-02-05、2026/02/05 13:05:09、2026.02.05 00:00:00\r\n    const m = s.match(\r\n      /^(\\d{4})[./-](\\d{1,2})[./-](\\d{1,2})(?:[ T](\\d{1,2})(?::(\\d{1,2})(?::(\\d{1,2})(?:\\.(\\d{1,3}))?)?)?)?$/\r\n    )\r\n    if (m) {\r\n      const year = Number(m[1])\r\n      const month = Number(m[2]) - 1\r\n      const day = Number(m[3])\r\n      const hh = m[4] != null ? Number(m[4]) : 0\r\n      const mm = m[5] != null ? Number(m[5]) : 0\r\n      const ss = m[6] != null ? Number(m[6]) : 0\r\n      const ms = m[7] != null ? Number(String(m[7]).padEnd(3, '0')) : 0\r\n\r\n      const d = new Date(year, month, day, hh, mm, ss, ms) // 這裡用「本地時區」\r\n      const t = d.getTime()\r\n      return Number.isFinite(t) ? t : null\r\n    }\r\n\r\n    return null\r\n  },\r\n  /**\r\n   * expireTime 的單位容錯：\r\n   * - 傳 30 / \"30\" -> 當作「秒」\r\n   * - 傳 30000 / \"30000\" -> 當作「毫秒」\r\n   * - 也可以直接傳 \"30s\" / \"5m\" / \"2h\" / \"1d\"\r\n   */\r\n  _parseDurationToMs(expireTime) {\r\n    if (expireTime == null || expireTime === '') return null\r\n\r\n    // number\r\n    if (typeof expireTime === 'number') {\r\n      if (!Number.isFinite(expireTime)) return null\r\n      // 小於 1e12 不可能是時間戳，這裡只判斷秒/毫秒\r\n      // 小於 1e6(約 16 分鐘) 通常是秒；更大多半是毫秒\r\n      return expireTime < 1e6 ? Math.round(expireTime * 1000) : Math.round(expireTime)\r\n    }\r\n\r\n    const s = String(expireTime).trim()\r\n    if (!s) return null\r\n\r\n    // 形如 \"30s\" / \"5m\" / \"2h\" / \"1d\"\r\n    const unit = s.match(/^(\\d+(?:\\.\\d+)?)(ms|s|m|h|d)$/i)\r\n    if (unit) {\r\n      const n = Number(unit[1])\r\n      const u = unit[2].toLowerCase()\r\n      if (!Number.isFinite(n)) return null\r\n      const map = { ms: 1, s: 1000, m: 60000, h: 3600000, d: 86400000 }\r\n      return Math.round(n * map[u])\r\n    }\r\n\r\n    // 純數字字串：同 number 規則\r\n    if (/^\\d+(\\.\\d+)?$/.test(s)) {\r\n      const n = Number(s)\r\n      if (!Number.isFinite(n)) return null\r\n      return n < 1e6 ? Math.round(n * 1000) : Math.round(n)\r\n    }\r\n\r\n    return null\r\n  },\r\n  _formatTime(remainingMs, format) {\r\n    const pad2 = (n) => String(n).padStart(2, '0')\r\n    const totalSec = Math.max(0, Math.ceil(remainingMs / 1000))\r\n\r\n    if (format === 'sss') return String(totalSec)\r\n\r\n    const hh = Math.floor(totalSec / 3600)\r\n    const mm = Math.floor((totalSec % 3600) / 60)\r\n    const ss = totalSec % 60\r\n\r\n    if (format === 'hh:mm:ss') {\r\n      return `${pad2(hh)}:${pad2(mm)}:${pad2(ss)}`\r\n    }\r\n\r\n    // 'mm:ss'：分鐘可超過 59（例如 90 分鐘會顯示 90:00）\r\n    const totalMin = Math.floor(totalSec / 60)\r\n    return `${totalMin}:${pad2(ss)}`\r\n  },\r\n  /**\r\n   * - 傳入 remainingMs（剩餘毫秒）\r\n   */\r\n  _createCountdownTicker({ remainingMs, format, onTick, onDone }) {\r\n    const { _formatTime } = countdown\r\n    const initialMs = Number(remainingMs)\r\n    if (!Number.isFinite(initialMs) || initialMs < 0) {\r\n      throw new Error('createCountdownTicker: remainingMs must be a finite number >= 0')\r\n    }\r\n\r\n    const expireMs = Date.now() + initialMs\r\n\r\n    let rafId = 0\r\n    let stopped = false\r\n    let lastSec = null\r\n    let doneCalled = false\r\n\r\n    const stop = () => {\r\n      stopped = true\r\n      if (rafId) cancelAnimationFrame(rafId)\r\n      rafId = 0\r\n    }\r\n\r\n    const loop = () => {\r\n      if (stopped) return\r\n\r\n      const now = Date.now()\r\n      const leftMs = Math.max(0, expireMs - now)\r\n      const leftSec = Math.max(0, Math.ceil(leftMs / 1000))\r\n      const isExpired = leftMs <= 0\r\n\r\n      // 每秒只更新一次\r\n      if (lastSec !== leftSec) {\r\n        lastSec = leftSec\r\n\r\n        onTick?.({\r\n          remainingMs: leftMs,\r\n          remainingSec: leftSec,\r\n          value: _formatTime(leftMs, format),\r\n          format,\r\n          isExpired,\r\n        })\r\n      }\r\n\r\n      // onTick 可能會觸發外部呼叫 onStop()，再檢查一次\r\n      if (stopped) return\r\n\r\n      if (isExpired) {\r\n        stop()\r\n        if (!doneCalled) {\r\n          doneCalled = true\r\n          onDone?.()\r\n        }\r\n        return\r\n      }\r\n\r\n      // stopped 確認後才排下一個 frame\r\n      rafId = requestAnimationFrame(loop)\r\n    }\r\n\r\n    rafId = requestAnimationFrame(loop)\r\n\r\n    return { stop }\r\n  },\r\n\r\n  /**\r\n   * 存 countdown\r\n   * @param {*} startTime - 有值就用；無值就 new Date()\r\n   * @param {*} expireTime - duration (秒/毫秒/或帶單位字串)；到期時間 = start + duration\r\n   * @param {string} format - 'hh:mm:ss' | 'mm:ss' | 'sss'\r\n   * @param {string} storageName - localStorage key\r\n   * @param {function} onTick - 每秒計算回傳的時間\r\n   * @param {function} onDone - 時間到的事件\r\n   */\r\n  onStart({ startTime, expireTime, format, storageName, onTick, onDone }) {\r\n    const { _format, _parseToMs, _parseDurationToMs, _formatTime, _createCountdownTicker, onStop } =\r\n      countdown\r\n    const startMs = startTime ? _parseToMs(startTime) : Date.now()\r\n    if (!Number.isFinite(startMs)) throw new Error('onStart: invalid startTime')\r\n\r\n    const durationMs = _parseDurationToMs(expireTime)\r\n    if (!Number.isFinite(durationMs)) throw new Error('onStart: invalid expireTime (duration)')\r\n\r\n    const expireMs = startMs + durationMs\r\n\r\n    const payload = {\r\n      startMs,\r\n      expireMs,\r\n      durationMs,\r\n      createdAtMs: Date.now(),\r\n      v: 1,\r\n    }\r\n\r\n    const hasStorage = typeof storageName === 'string' && storageName.trim() !== ''\r\n    const key = hasStorage ? storageName.trim() : ''\r\n\r\n    if (hasStorage) {\r\n      localStorage.setItem(key, JSON.stringify(payload))\r\n    }\r\n\r\n    const remainingMs = Math.max(0, expireMs - Date.now())\r\n    const formatText = _formatTime(remainingMs, format || _format)\r\n\r\n    onStop({\r\n      invokeDone: false,\r\n    })\r\n\r\n    // 先存起來，讓 countdown.onStop() 也能觸發\r\n    countdown._doneFn = () => {\r\n      // done 時也把 stop 清掉\r\n      countdown._stopFn = null\r\n      countdown._doneFn = null\r\n\r\n      if (hasStorage) localStorage.removeItem(key)\r\n      onDone?.()\r\n    }\r\n\r\n    const ticker = _createCountdownTicker({\r\n      remainingMs,\r\n      format,\r\n      onTick,\r\n      onDone: () => {\r\n        // 讓 ticker 自己到期時也走同一套 done（避免重複寫邏輯）\r\n        countdown.onStop({\r\n          invokeDone: true,\r\n        })\r\n      },\r\n    })\r\n\r\n    // 存起來給 onStop 用\r\n    countdown._stopFn = ticker.stop\r\n\r\n    return {\r\n      data: payload,\r\n      remainingMs,\r\n      remainingSec: Math.ceil(remainingMs / 1000),\r\n      formatText,\r\n      isExpired: remainingMs <= 0,\r\n      stop: ticker.stop,\r\n    }\r\n  },\r\n  /**\r\n   * 停止目前倒數（取消 requestAnimationFrame）\r\n   * - 預設會同時觸發 onDone（你要求的行為）\r\n   * @param {Object} opts\r\n   * @param {boolean} [opts.invokeDone = true] - 是否要觸發 done\r\n   */\r\n  onStop(opts) {\r\n    const { invokeDone } = opts || {}\r\n    const { _stopFn, _doneFn } = countdown\r\n\r\n    // 先清掉引用，避免重入 / 重複呼叫\r\n    countdown._stopFn = null\r\n    countdown._doneFn = null\r\n\r\n    if (typeof _stopFn === 'function') _stopFn()\r\n    if (invokeDone !== false && typeof _doneFn === 'function') _doneFn()\r\n  },\r\n  /**\r\n   * 取 countdown 剩餘時間\r\n   * @param {string} storageName - localStorage key\r\n   */\r\n  onGet(storageName) {\r\n    if (!storageName) throw new Error('onGet: storageName is required')\r\n\r\n    const raw = localStorage.getItem(storageName)\r\n    if (!raw) {\r\n      return {\r\n        ok: false,\r\n        reason: 'NOT_FOUND',\r\n        remainingMs: 0,\r\n        remainingSec: 0,\r\n        isExpired: true,\r\n        data: null,\r\n      }\r\n    }\r\n\r\n    let data = null\r\n    try {\r\n      data = JSON.parse(raw)\r\n    } catch {\r\n      // 壞資料直接清掉\r\n      localStorage.removeItem(storageName)\r\n      return {\r\n        ok: false,\r\n        reason: 'BAD_JSON',\r\n        remainingMs: 0,\r\n        remainingSec: 0,\r\n        isExpired: true,\r\n        data: null,\r\n      }\r\n    }\r\n\r\n    const expireMs = Number(data?.expireMs)\r\n    const startMs = Number(data?.startMs)\r\n\r\n    if (!Number.isFinite(expireMs) || !Number.isFinite(startMs)) {\r\n      localStorage.removeItem(storageName)\r\n      return {\r\n        ok: false,\r\n        reason: 'BAD_DATA',\r\n        remainingMs: 0,\r\n        remainingSec: 0,\r\n        isExpired: true,\r\n        data: null,\r\n      }\r\n    }\r\n\r\n    const now = Date.now()\r\n    const remainingMs = Math.max(0, expireMs - now)\r\n    const isExpired = now >= expireMs\r\n\r\n    // 過期就清掉\r\n    if (isExpired) localStorage.removeItem(storageName)\r\n\r\n    return {\r\n      ok: true,\r\n      remainingMs,\r\n      remainingSec: Math.ceil(remainingMs / 1000),\r\n      isExpired,\r\n      data,\r\n    }\r\n  },\r\n}\r\n\r\n/**\r\n * 取得 location.search 的 key 值\r\n * - key 傳入 query 的 key\r\n */\r\nexport const onQueryParam = (key) => {\r\n  if (!key) return null\r\n  const { search } = window.location\r\n  const params = new URLSearchParams(search)\r\n  return params.get(key)\r\n}\r\n\r\n// 同時執行多支 api，會等全部回傳\r\nexport const awaitAllPromise = async (apis) => {\r\n  try {\r\n    await Promise.all(apis)\r\n  } catch (error) {\r\n    console.log(error)\r\n  }\r\n}\r\n"],"version":3}